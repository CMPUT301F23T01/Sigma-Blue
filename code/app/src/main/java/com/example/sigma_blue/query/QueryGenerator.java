package com.example.sigma_blue.query;

import com.example.sigma_blue.R;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.Query;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.List;

/**
 * For constant query changes.
 */
public class QueryGenerator {
    private Query query;
    private final CollectionReference baseQuery;

    /**
     * Base constructor. Takes in the reference to the collection being queried
     * @param baseQuery is the Collection reference that is being used as the
     *                  baseline for the query generator.
     */
    public QueryGenerator(CollectionReference baseQuery) {
        this.baseQuery = baseQuery;
        resetQuery();
    }

    /**
     * Resets the query back to the base form. Needed for resetting the
     * generator to produce the default view.
     */
    public void resetQuery() {
        this.query = baseQuery;
    }

    public Query getQuery() {
        return this.query;
    }

    /**
     * Private setter as outside modification is not wanted.
     * @param modded is the modified query that is replacing the current query
     */
    private void setQuery(final Query modded) {
        if (query != null) {
            this.query = modded;
        } else {
            throw new IllegalArgumentException("Passing null query");
        }
    }

    /**
     * Updates the query being generated by the database.
     * @param sortBy the field that is being used for sorting
     * @param direction either ASCENDING or DESCENDING
     */
    public static Query sortQuery(Query query, SortField sortBy,
                                  Query.Direction direction) {
        return query.orderBy(sortBy.getDbField(), direction);
    }

    /**
     * This method will return a new query object with an equals filter applied
     * to it.
     * @param field This is the document field that is being matched
     * @param keyword This is the keyword being used for filtering
     */
    public static Query filterEqualsQuery(Query query, String field, String keyword) {
        return query.whereEqualTo(field, keyword);
    }

    /**
     * Updates the query to return the values between two range.
     * @param field is the field being compared with
     * @param lowerRange is the lower bound that will be included
     * @param upperRange is the upper bound that will be included
     */
    public static Query filterRangeQuery(Query query, String field, String lowerRange,
                                 String upperRange) {
        return query.whereLessThanOrEqualTo(field, upperRange)
                .whereGreaterThanOrEqualTo(field, lowerRange);
    }

    /**
     * Updates the query to return the dates between two range.
     * @param field is the field being compared with
     * @param startDate is the lower bound that will be included
     * @param endDate is the upper bound that will be included
     */
    public static Query filterRangeQuery(Query query, String field, LocalDate startDate, LocalDate endDate) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        // pattern is in the strings file, but using android methods here makes testing harder
        String lowerRange = startDate.format(formatter);
        String upperRange = endDate.format(formatter);

        return filterRangeQuery(query, field, lowerRange, upperRange);
    }
    /**
     * This filters the item retrieved by only including documents where the
     * field is one of the included items in the input list.
     * @param field is the field being checked
     * @param inclusionList is the inclusion list
     */
    public void filterInclusiveQuery(String field, List<Object> inclusionList) {
        setQuery(query.whereIn(field, inclusionList));
    }
}
